import logging
import os
from pathlib import Path
from typing import List

from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from google import genai
from dotenv import load_dotenv

from backend.models import ChatMessage, ChatRequest, ChatResponse
from backend.system_instruction import SYSTEM_PROMPT

MODEL_NAME = "gemini-3-pro-preview"

# Load .env both from current working dir and backend/.env (local dev)
load_dotenv()
backend_env = Path(__file__).parent / ".env"
if backend_env.exists():
    load_dotenv(backend_env, override=True)

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("ppt-copilot")

allowed_origins_env = os.getenv(
    "ALLOWED_ORIGINS",
    "https://localhost:5173,https://localhost:3000,https://localhost:4300",
)
ALLOWED_ORIGINS = [o.strip() for o in allowed_origins_env.split(",") if o.strip()]

app = FastAPI(title="PPT Copilot Backend")

app.add_middleware(
    CORSMiddleware,
    allow_origins=ALLOWED_ORIGINS,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

_client: genai.Client | None = None


def _extract_assistant_text(response: genai.types.GenerateContentResponse) -> str:
    """
    Extract the first text part from the Gemini response, even when `response.text` is empty.
    """
    if response is None:
        return ""

    # Prefer the aggregated text property when available.
    text = getattr(response, "text", None)
    if text:
        return text

    candidates = getattr(response, "candidates", None) or []
    for cand in candidates:
        # Some SDK versions expose cand.text directly.
        cand_text = getattr(cand, "text", None)
        if cand_text:
            return cand_text

        content = getattr(cand, "content", None)
        parts = getattr(content, "parts", None) or []
        for part in parts:
            part_text = getattr(part, "text", None)
            if part_text:
                return part_text

    return ""


def _extract_block_reason(response: genai.types.GenerateContentResponse):
    prompt_feedback = getattr(response, "prompt_feedback", None)
    return getattr(prompt_feedback, "block_reason", None)


def get_client() -> genai.Client:
    """Lazily build the Gemini client to surface a clear error if the API key is missing."""
    global _client
    if _client is None:
        api_key = os.environ.get("GEMINI_API_KEY")
        if not api_key:
            raise HTTPException(status_code=500, detail="GEMINI_API_KEY is not set")
        _client = genai.Client(api_key=api_key)
    return _client


def to_genai_contents(messages: List[ChatMessage]) -> list[dict]:
    """Map chat history to the format expected by google-genai."""
    contents = []
    for msg in messages:
        contents.append(
            {
                "role": msg.role,
                "parts": [{"text": msg.content}],
            }
        )
    return contents


@app.get("/health")
def health():
    return {"status": "ok"}


@app.post("/api/chat", response_model=ChatResponse)
def chat(req: ChatRequest):
    if not req.messages:
        raise HTTPException(status_code=400, detail="messages is required")

    client = get_client()
    contents = to_genai_contents(req.messages)

    try:
        response = client.models.generate_content(
            model=MODEL_NAME,
            contents=contents,
            config={
                "system_instruction": SYSTEM_PROMPT,
                "max_output_tokens": 512,
                "temperature": 1.0,
            },
        )
    except Exception as exc:
        raise HTTPException(status_code=502, detail=f"Gemini error: {exc}") from exc

    # Extract text defensively (SDK versions differ).
    assistant_text = _extract_assistant_text(response)
    block_reason = _extract_block_reason(response)

    if not assistant_text and block_reason:
        # Surface a user-friendly message instead of a 500/502.
        assistant_text = f"(Réponse bloquée par Gemini : {block_reason}. Réessaie avec un prompt plus simple.)"

    if not assistant_text:
        raise HTTPException(status_code=502, detail="Empty response from Gemini")

    logger.info(
        "chat completed",
        extra={
            "messages_count": len(req.messages),
            "assistant_chars": len(assistant_text),
            "block_reason": block_reason,
        },
    )

    # Token usage is left optional; the SDK may expose it via response.candidates[0].usage_metadata.
    return ChatResponse(
        assistant_text=assistant_text,
        input_tokens=None,
        output_tokens=None,
    )


if __name__ == "__main__":
    import uvicorn

    ssl_keyfile = None
    ssl_certfile = None

    # Check for Office Add-in dev certs
    # Usually in ~/.office-addin-dev-certs/
    home_dir = Path.home()
    cert_dir = home_dir / ".office-addin-dev-certs"
    possible_key = cert_dir / "localhost.key"
    possible_cert = cert_dir / "localhost.crt"

    if possible_key.exists() and possible_cert.exists():
        logger.info(f"Found SSL certs at {cert_dir}")
        ssl_keyfile = str(possible_key)
        ssl_certfile = str(possible_cert)
    else:
        logger.warning("No SSL certs found. Running in HTTP mode (might fail in Web Office).")

    uvicorn.run(
        "backend.main:app",
        host="0.0.0.0",
        port=8000,
        reload=True,
        ssl_keyfile=ssl_keyfile,
        ssl_certfile=ssl_certfile,
    )

